{"id":"js/shaders/vert.glsl","dependencies":[],"generated":{"js":"module.exports = `\n/*\nAuthor Frédéric Dilé\n19/02/2022\nfrederic.dile@gmail.com\n*/\nuniform float time;\nuniform float progress;\nuniform float freq;\nuniform float amp;\nuniform float offsetY;\n\nvarying vec3 vViewPosition;\nvarying float vWave;\n\n#define PI 3.1415926538\n\n\nvoid main() \n{   \n\n    vec3 pos = position;\n    vViewPosition = pos.xyz;\n\n    // Good\n    // pos.z += sin(sin(sin(sin((pos.y + offsetY ) * freq + time * progress )))) * amp;\n\n    // More rounded\n    // pos.z = -sin(sin((sin( (pos.y  + offsetY) * freq + time * progress ) + sin( pos.z * freq )))) * amp;\n\n    // Half circles equation\n    // Adapted from https://math.stackexchange.com/questions/2781755/semicircle-periodic-wave\n\n    float phi = 0.;\n    float R= 1.;\n    float A= R * sin( phi );\n    float B= R * cos( phi );\n    float py = pos.y + offsetY + time * progress;\n    float S = sign( sin( ( PI * py ) / 2. * B ) );\n    float M = mod( py, 2. * B );\n\n    pos.z = S * ( sqrt( pow( R, 2.) - pow( (M - B), 2. ) ) - A );\n\n    vWave = pos.z;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n\n}\n\n\n\n`"},"sourceMaps":null,"error":null,"hash":"fb04d51c05ac7913725dd7f0e9b7ff54","cacheData":{}}